---
title: 数据库设计模式
date: 2024-07-02 21:56:22
categories:
  - 数据库
tags:
  - 数据库
  - 范式
  - 设计模式
---

## 多表之间的关系

1. 一对一

   如：人和身份证号

    * 通过在任意的一方建立**唯一外键**，链接到另一方主键
    * 建立模型时处理为一张表
2. 一对多

   如：部门和员工

    * 通过在多的一方建立外键，链接到另一方主键
3. 多对多

   如：学生和课程

    * 多对多关系需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为该表的外键分别链接另两方的主键


## 设计范式


> 第一范式 -> 第二范式
>
> **在1NF基础上消除非主属性对主码的部分函数依赖**
>
> 第二范式 -> 第三范式
>
> **在2NF基础上消除传递依赖**
>
> 第三范式 -> 巴斯-科德范式
>
> **在3NF基础上消除对主码子集的依赖**
>
>> 如员工表中有采购上限字段，采购上限字段仅有采购部门可用，应当建立单独的表存储改字段
>>


范式来自英文Normal form，简称NF。要想设计—个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。

[关系数据库](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93)有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、[第四范式](https://baike.baidu.com/item/%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F)(4NF）和[第五范式](https://baike.baidu.com/item/%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F)（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。


**1、第一范式（1NF）：**

所谓第一范式（1NF）是指在[关系模型](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B)中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

说明：在任何一个[关系数据库](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93)中，第一范式（1NF）是对[关系模式](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F)的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的[关系模型](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B)。

**2、第二范式（2NF）**

![image.png](./img/2NF示例表.png)  
![image.png](./img/2NF.png)

在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加）

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

**3、第三范式（3NF）**

在2NF基础上，任何非主[属性](https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7)不依赖于其它非主属性（在2NF基础上消除传递依赖）

![数据库范式](./img/3NF.png "数据库范式")

第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。

**4、巴斯-科德范式（BCNF）**

Boyce-Codd Normal Form（巴斯-科德范式）

在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）

巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。

## 第四范式的定义

设关系R（X，Y，Z），其中X，Y，Z是成对的、不相交属性的集合。若存在非平凡多值依赖，则意味着对R中的每个属性![](assets/net-img-28d477ed070c0bba533ce5a3130f6da6-20220318003035-wsdxigo.svg)

存在有函数依赖![](assets/net-img-a52af6c2e682dc07079a52587d02b13f-20220318003035-ndtrggz.svg)

（X必包含键）。那么![](assets/net-img-286faf0ae87fa7b3acfe828f483f78c3-20220318003035-oxycayy.svg)

。

换句话说，当关系R的属性集合X是非平凡多值依赖的域，它就包含关系R的键。则![](assets/net-img-286faf0ae87fa7b3acfe828f483f78c3-20220318003035-zfpplc4.svg)

。这个定义和BCNF定义唯一的不同点是后者研究非平凡[多值依赖](https://baike.baidu.com/item/%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96)的域。由于函数依赖是多值依赖的特定情况，因此，这直观地说明了4NF比BCNF更强的原因。

显然，若关系属于4NF，则它必属于BCNF；而属于BCNF的关系不一定属于4NF。


## 规范化小结

在关系数据库中，对关系的最基本要求的满足第一范式。这样的关系模式是合法的，允许的。但人们发现有些关系模式存在插入、删除、修改异常、数据冗余等弊病，人们寻求解决这些问题的方法，这就是规范化的目的。

规范化的基本思想是逐步消除数据依赖中不合适的部分，使关系数据库模式的各关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。

让一个关系只描述一个实体或者实体间的一种联系。若多于一个实体（包括概念、联系），就把它“分离”出来。因此，所谓规范化，实质上是概念的单一化，即一个关系表示一个实体。

人们认识这个原则是经历了一个过程的。是认识非主属性的部分函数依赖的危害开始，2NF，3NF，BCNF，4NF的提出是这个认识过程逐步深化的标志。规范化的过程可概括如下：

（1）取原始的1NF关系投影，消去非主属性对键的部分函数依赖，从而产生一组2NF关系。

（2）取2NF关系的投影，消去非主属性对键的[传递函数依赖](https://baike.baidu.com/item/%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/9816957)，产生一组3NF关系。

（3）取这些3NF的投影，消去决定因素不是键的函数依赖。产生一组BCNF关系。

（4）取这些BCNF关系的投影，消去其中不是函数依赖的非平多值依赖，产生一组4NF关系。

规范化过程，是通过投影分解运算，把低一级范式的关系模式“分离”为若干个高一级范式的关系模式。但这种投影分解不是唯一的，要求分解“既保持[函数依赖](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96)”，又具有“无损连接性”。

## 目的原则

规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小。便于插入、删除和更新。

遵从概念单一化“一事一地”原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。

一个关系模式接着分解可以得到不同关系模式集合，也就是说分解方法不是惟一的。最小冗余的要求必须以分解后的数据库能够表达原来数据库所有信息为前提来实现。其根本目标是节省存储空问，避免数据不一致性，提高对关系的操作效率，同时满足应用需求。实际上，并不一定要求全部模式都达到BCNF不可。有时故意保留部分冗余可能更方便数据查询。尤其对于那些更新频度不高，查询频度极高的数据库系统更是如此。

## 反范式

规范化的优点是明显的，它避免了大量的数据冗余，节省了存储空间，保持了数据的一致性。当一个库里的数据经常发生变化时，达到3NF的库可以使用户不必在超过两个以上的地方更改同一个值。那么是不是只要把所有的表都规范为3NF后，数据库的设计就是最优的呢?这可不一定。范式越高意味着表的划分更细，一个数据库中需要的表也就越多，用户不得不将原本相关联的数据分摊到多个表中。当用户同时需要这些数据时只能采用连接表的形式将数据重新合并在一起。同时把多个表联接在一起的花费是巨大的，尤其是当需要连接的两张或者多张表数据非常庞大的时候，表连接操作几乎是一个噩梦，这严重地降低了系统运行性能。^